#! /usr/bin/python3
#! coding: utf-8

'''
このスクリプトはPython 3.6以上でサポートされています。

このスクリプトはVCFを入力ファイルとし、下流の解析フローへ適した形へと変換します。
特に何も指定しない場合は次のようなファイルになります。
・ヘッダーが取り除かれます。
・多型が複数含まれるSNP(Multi allelic site)が取り除かれます。
・各系統のジェノタイプデータが下記の様にして数値データに変換されます。
    野生型ホモ -> 1
    ヘテロ -> 0
    変異型ホモ -> -1

以下はオプションの説明です。
・VCFのヘッダーを残したい場合は -kh(--keep-header)のフラグを立て下さい。
・ジェノタイプデータを数値データに変換したくない場合は -kg(--keep-GT)のフラグを立て下さい。
  この場合ジェノタイプデータは下記のようにGT部分のみを残した形になります。
  1/1:0,25:25:75:1115,75,0 -> 1/1
・ジェノタイプを数値データに変換する際の規則を変更したい場合は -cr(--convert-rule)で指定して下さい。
  例のようにコロンで区切り 野生型ホモ:ヘテロ:変異型ホモ の順番で指定して下さい。
  例) -cr -1:NA:1
・マイナーアレル頻度によるフィルタリングを行いたい場合は -mM(--min-MAF)で指定して下さい。
  0 ~ 0.5の間で指定し、指定された頻度以下のアレルを持つSNP(行)は取り除かれます。
・欠損値の割合によるフィルタリングを行いたい場合は -mN(--max-NA)で指定して下さい。
  指定した割合以上の欠損値を含むSNP(行)は取り除かれます。
・入力VCF中で不要なフィールド(列)があれば -rf(--remove-fields)で指定して下さい。
  例のようにコロンで区切り指定して下さい。
  例) -rf POS:ID:FILTER

入出力ファイルは.vcf(.vcf.gz)もしくは.txtをサポートしています。
入出力に圧縮形式を利用する場合は、処理時間が大幅に伸びる可能性があります。ディスクに余裕がある場合は、非圧縮形式を推奨します。
このスクリプトで出力されたファイルに対して再度このスクリプトを用いると予期せぬ結果が生じる可能性があります。
'''


import argparse
from collections import Counter
import datetime
import gzip
from logging import basicConfig, getLogger, StreamHandler, FileHandler, info, INFO, Formatter
import os
import re
import sys
import time
from typing import Counter, IO, List, Pattern, Union


################ Setting of logger ################
logger = getLogger(__name__)
logger.setLevel(INFO)

sh = StreamHandler()
sh.setLevel(INFO)
sh.setFormatter(Formatter("%(asctime)s %(levelname)8s %(message)s"))

fh = FileHandler(filename=__file__ + datetime.datetime.now().isoformat() +".log")
fh.setLevel(INFO)
fh.setFormatter(Formatter("%(asctime)s %(levelname)8s %(message)s"))

logger.addHandler(sh)
logger.addHandler(fh)
################ End of setting of logger ################


################ Defining functions ################
def runtime_counter(start: float, end: float) -> str: 
    """
    Arguments:
    ===
        start: float
            Start time
        end: float
            Finish time
        You can get each argumemts using time.time()

    Returns:
    ===
        str
            Run time which calculated end - start
    """
    runtime: str = str(round((end - start), 2))
    return runtime


def open_file(file_path: str, mode: str) -> Union[IO, bool]:
    """
    Arguments:
    ===
        file_path: str
            Path to input/output VCF
            .vcf, .vcf.gz, .txt format is supported
        mode: str
            
    Returns:
    ===
        IO
            If input/output file is supported, return opened file
        bool
            If input/output file is not supported, return False
    """
    if file_path.endswith(".vcf.gz"):
        return gzip.open(file_path, mode=mode+"t")
    elif file_path.endswith(".vcf") or file_path.endswith(".txt"):
        return open(file_path, mode=mode)
    else:
        return False


def multi_pop(LIST: List[str], INDEX: List[int]) -> List[str]:
    """
    Arguments:
    ===
        LIST: List[str]
            Some list
        INDEX: List[int]
            Index(es) list to be removed from LIST.
    Returns:
    ===
        List[str]
            List from which the specified index was removed.
    """
    INDEX.sort(reverse=True)
    for i in INDEX:
        LIST.pop(i)
    return LIST


def check_alt(alt: str) -> bool:
    """
    Arguments:
    ===
        alt: str
            Each ALT field of input VCF
    Returns:
    ===
        bool
            If input VCF contains multi allelic site, return True
    """
    #alt: str = line.split("\t")[4]
    if alt.count(","):
        return True


def remain_only_GT(geno: str) -> str:
    """
    Arguments:
    ===
        geno: str
            Each genotype field of input VCF
    Returns:
    ===
        str
           Return only "GT" in genotype field
    """
    #geno_list: List[str] = line.split("\t")[9:]
    #expected_GT: List[str] = ["0/0", "0/1", "1/0", "1/1", "0|0", "0|1", "1|0", "1|1", "./."]
    expected_GT: List[str] = ["0/0", "0/1", "1/0", "1/1", "./."]
    GT: str = geno.split(":")[0].replace("|", "/")

    #GATKを使った際にフォーマットに則らないジェノタイプが出てきたことがある。(仕様？)
    #そうしたジェノタイプは欠損値に変換する。
    if GT not in expected_GT:
        GT = "./."
    return GT


def GT2numeric(GT_list: List[str], convert_rule: List[str]) -> List[str]:
    """
    Arguments:
    ===
        GT_list: List[str]
            List generated by remain_only_GT function
        convert_rule: List[str]
            "REF:HETERO:ALT"
    Returns:
    ===
        List[str]
            GT will be changed by the following rules to numeric data or NA
                0/0 -> REF
                0/1, 1/0 -> HETERO
                1/1 -> ALT
                ./. -> NA                
    """
    REF, HETERO, ALT = convert_rule
    GT_list = [REF if i == "0/0" else i for i in GT_list]
    GT_list = [HETERO if i == "0/1" else i for i in GT_list]
    GT_list = [HETERO if i == "1/0" else i for i in GT_list]
    GT_list = [ALT if i == "1/1" else i for i in GT_list]
    GT_list = ["NA" if i == "./." else i for i in GT_list]
    return GT_list


def calc_MAF(GT_list: List[str]) -> float:
    """
    Arguments:
    ===
        GT_list: List[str]
            List generated by remain_only_GT function
    Returns:
    ===
        float
            Minor allele frequency
    """
    Count_Summary: Counter = Counter(GT_list)
    Genotyped: int = (sum(Count_Summary.values()) - Count_Summary("./.")) * 2
    ALT_num: int = Count_Summary("0/1") + Count_Summary("1/0") + Count_Summary("1/1") * 2
    AAF: float = ALT_num / Genotyped
    MAF: float = (AAF, 1 - AAF)
    return MAF


def calc_NA_rate(GT_list: List[str]) -> float:
    """
    Arguments:
    ===
        GT_list: List[str]
            List generated by remain_only_GT function
    Returns:
    ===
        float
            Percentage of NA
    """
    Count_Summary: Counter = Counter(GT_list)
    Num: int = sum(Count_Summary.values())
    NA_Num: int = sum(Count_Summary["./."])
    return NA_Num / Num


def change_Chrom(Chrom: str) -> str:
    """
    Arguments:
    ===
        Chrom: str
            Chromosome information
    Returns:
    ===
        str
            Extract only number from Chrom
    """
    regix = re.compile(r"[1-9]\d*")
    return re.findall(regix, Chrom)[-1]
################ End of defining functions ################


def main():
    ################ Setting command line arguments ################
    parser=argparse.ArgumentParser(description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)

    ##入力ファイルのパス(必須)    
    parser.add_argument("-i", "--input-file-path", type=str, action="store",
        dest="inputFilePath", required=True, help="Path to input file.")
    
    ##出力ファイルのパス(必須)
    parser.add_argument("-o", "--output-file-path", type=str, action="store",
        dest="outputFilePath", required=True, help="Path to output file.")
    
    ##ヘッダーを残すか否か(デフォルトは残さない)
    parser.add_argument("-kh", "--keep-header", action="store_true",
        dest="keep_header", default=False,
        help="If use this argument, leave vcf header.(default=False)")

    ##ジェノタイプフィールドを数値データに変換するか否か(デフォルト(False)は変換する)
    parser.add_argument("-kg", "--keep-GT", action="store_true",
        dest="keep_GT", default=False,
        help="If use this argument, genotype will not be converted to numeric.\
            (default=False)")
    
    ##各ジェノタイプの変換ルール 野生型ホモ:ヘテロ:変異型ホモ(keep_GTがTrueのときは使用されない)
    parser.add_argument("-cr", "--convert-rule", type=str, action="store", 
        dest="convert_rule", default="1:0:-1",
        help="Conversion rule for converting genotype to numeric data.\
        Specify in the following order. \
        REF:HETERO:ALT (default=1:0:-1)")
    
    ##マイナーアレル頻度によるフィルタリング(デフォルトはNA、フィルタリングしない)
    parser.add_argument("-mM", "--min-MAF", action="store",
        dest="min_MAF", default="NA",
        help="SNP below min-MAF will be removed. 0 ~ 0.5 (default=\"NA\", nothing will be removed)")
    
    ##欠損値の割合によるフィルタリング(デフォルトはNA、フィルタリングしない)
    parser.add_argument("-mN", "--max-NA", action="store",
        dest="max_NA", default="NA",
        help="SNP above max-NA will be removed. 0 ~ 1 (default=\"NA\", nothing will be removed")
    
    ##VCFの不要なフィールドを指定(デフォルトは何も指定していない、False)
    parser.add_argument("-rf", "--remove-fields", action="store",
        dest="remove_fields", default=False,
        help="Fileds of VCF to remove. Specify as the following, separated by colons(:)\
        ID:QUAL:FORMAT (default=False)")


    args = parser.parse_args()

    input_file_path: str = args.inputFilePath
    output_file_path: str = args.outputFilePath
    keep_header: bool = args.keep_header
    keep_GT: bool = args.keep_GT
    convert_rule: List[str] = list(args.convert_rule.split(":")) ##リストに変換する
    min_MAF: Union[float, bool] = args.min_MAF
    max_NA: Union[float, bool] = args.max_NA
    if min_MAF != "NA" and (min_MAF < 0.0 or min_MAF > 0.5):
        logger.info("min_MAF must be 0 ~ 1")
        sys.exit()
    if max_NA != "NA" and (max_NA < 0.0 or max_NA > 1.0):
        logger.info("max_NA must be 0 ~ 1")
        sys.exit()
    
    ##リストに変換する、何も指定されていない場合空のリストを作る。
    remove_fields: List[str] = \
        args.remove_fields.split(":") if args.remove_fields else []
    
    ##指定したfieldsのインデックスを取り出す。
    All_fields = {"CHROM":0, "POS":1, "ID":2, "REF":3, "ALT":4, \
        "QUAL":5, "FILTER":6, "INFO":7, "FORMAT":8}
    remove_fields_index: List[int] = []
    for field in remove_fields:
        try:
            remove_fields_index.append(All_fields[field])
        except KeyError:
            logger.info(f"{field}は入力ファイルに含まれていません。")
            sys.exit()
    
    ################ End of setting command line arguments ################


    ################ File Open ################
    if not open_file(input_file_path, "r"):
        logger.info("Invalid format!")
        logger.info("Only VCF format (.vcf, .vcf.gz, .txt) is supported for input files.")
        sys.exit()
    else:
        input_file: IO = open_file(input_file_path, "r")

    if not open_file(output_file_path, "w"):
        logger.info("Invalid format!")
        logger.info("Only VCF format (.vcf, .vcf.gz, .txt) is supported for output files.")
        sys.exit()
    else:
        output_file: IO = open_file(output_file_path, "w")
    
    ################ End of file Open ################

    ################ Main ################
    start: float = time.time()

    logger.info(__file__ + f"\n\
        \t\t\t\t--input_file_path {input_file_path}\n\
        \t\t\t\t--output_file_path {output_file_path}\n\
        \t\t\t\t--keep-header {keep_header}\n\
        \t\t\t\t--keep-GT {keep_GT}\n\
        \t\t\t\t--convert-rule {convert_rule}\n\
        \t\t\t\t--min-MAF {min_MAF}\n\
        \t\t\t\t--max-NA {max_NA}\n\
        \t\t\t\t--remove-fields {remove_fields}")


    logger.info("=======================================================")
    logger.info("Start program...")


    
    count_line: int = 1
    count_SNPs: int = 0
    multi_alt_site: int = 0
    under_MAF_site: int = 0
    above_NA_site: int = 0

    for line in input_file:
        line: str = line.rstrip("\n|\r|\r\n")

        ##header
        if line[0:2] == "##":
            if keep_header:
                output_file.write(line + "\n")
            else:
                pass

        ##headerのうち#CHROMから始まるもの
        elif line[0:6] == "#CHROM":
            line: List[str] = line.split()
            line[0] == "CHROM"
            ##指定されたremove_fieldsを削除
            line = multi_pop(line, remove_fields_index)
            new_line: str = "\t".join(line)
            output_file.write(new_line + "\n")

        ##bodyの部分
        else: 
            line: List[str] = line.split("\t")
            alt: str = line[4]
            if check_alt(alt):
                multi_alt_site += 1 ##multi allelic siteの場合は書き出さない
            else:
                line[9:] = list(map(remain_only_GT, line[9:]))
                if min_MAF != "NA" and calc_MAF(line[9:]) <= min_MAF:
                    under_MAF_site += 1  ##min_MAF以下のSNPは書き出さない
                elif max_NA != "NA" and calc_NA_rate(line[9:]) >= max_NA:
                    above_NA_site += 1  ##max_NA以上のSNPは書き出さない。
                else:
                    line[0] = change_Chrom(line[0])
                    if keep_GT:
                        line = multi_pop(line, remove_fields_index)
                        new_line: str = "\t".join(line)
                        output_file.write(new_line + "\n")
                    else:
                        line[9:] = GT2numeric(line[9:], convert_rule)
                        line = multi_pop(line, remove_fields_index)
                        new_line: str = "\t".join(line)
                        output_file.write(new_line + "\n")
                    count_SNPs += 1 
        count_line += 1

    input_file.close()
    output_file.close()
    end: float = time.time()
    logger.info("Success processing!")
    logger.info(f"Run Time = {runtime_counter(start, end)} seconds")
    logger.info(f"{count_SNPs} SNPs were written in your {output_file_path} .")
    if multi_alt_site:
        logger.info(f"{multi_alt_site} SNPs were multi allelic site, and they were removed.")
    if under_MAF_site:
        logger.info(f"{under_MAF_site} SNPs were under MAF, and they were removed.")
    if above_NA_site:
        logger.info(f"{above_NA_site} SNPs have more NA than you specified, and they were removed.")

    logger.info("=======================================================")
    ################ End of main ################


if __name__=="__main__":
    main()